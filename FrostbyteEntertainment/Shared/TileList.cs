using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace Frostbyte
{
    /// <summary>
    /// Wraper class for our dictionary that allows us to most efficiently obtain data from the dictionary
    /// Shared with The Level Editor
    /// </summary>
    public partial class TileList
    {
        #region Data
        /// <summary>
        /// Dict of the form [y,x]=Tile
        /// </summary>
        List<List<Tile>> mTiles = new List<List<Tile>>();

        /// <summary>
        /// All data that the level file contains in order from the file (for saving again)
        /// </summary>
        List<LevelObject> LevelParts = new List<LevelObject>();

        public Tuple<List<LevelObject>, List<List<Tile>>> Data
        {
            get
            {
                return new Tuple<List<LevelObject>, List<List<Tile>>>(LevelParts, mTiles);
            }
        }

        Index2D cache_key = new Index2D(-1, -1);
        Tile cache_value;
        #endregion Data

        #region Constructor
        internal TileList()
        {

        }

        public TileList(XDocument doc)
        {
            foreach (var elem in doc.Root.Descendants())
            {
                if (elem.Name == "Room")
                {
                    Add(Room.Parse(elem).AsLevelPart());
                }
                else if (elem.Name == "Walls")
                {
                    Add(BorderWalls.Parse(elem).AsLevelPart());
                }
                else if (elem.Name == "Wall")
                {
                    Add(Wall.Parse(elem).AsLevelPart());
                }
                else if (elem.Name == "Floor")
                {
                    Add(Floor.Parse(elem).AsLevelPart());
                }
                else if (elem.Name == "Tile")
                {
                    Add(Tile.Parse(elem));
                }
            }

        }
        #endregion Constructor

        #region Adds
        /// <summary>
        /// Adds a FrostByte.Tile to the grid and to ObjectList
        /// </summary>
        /// <param name="t">Room to add</param>
        /// <returns>Success</returns>
        internal bool Add(Tile t)
        {
            Add(t, t.GridCell.X, t.GridCell.Y);
            LevelParts.Add(t);
            return true;
        }

        /// <summary>
        /// Adds a Tile to the tile map but not list of objects
        /// </summary>
        /// <param name="t">The tile to add</param>
        /// <param name="x">The X grid location</param>
        /// <param name="y">The Y gird location</param>
        /// <returns></returns>
        internal bool Add(Tile t, int x, int y)
        {
            int gridwidth = x;
            if (mTiles.Count > 0)
                gridwidth = Math.Max(x, mTiles[0].Count - 1);
            //fills grid
            while (mTiles.Count < y + 1)
            {
                mTiles.Add(new List<Tile>());
            }
            for (int ypos = 0, yCount = mTiles.Count; ypos < yCount; ypos++)
            {
                List<Tile> row = mTiles[ypos];
                while (row.Count < gridwidth + 1)
                {
                    row.Add(new Tile() { GridCell = new Index2D(row.Count, ypos) });
                }
            }
            Remove(t);
            mTiles[y][x] = t;
            return true;
        }

        /// <summary>
        /// Adds the Room to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Room to add</param>
        /// <returns>Success</returns>
        internal bool Add(Room r)
        {
            LevelParts.Add(r);
            //add tiles to the list
            return true;
        }

        /// <summary>
        /// Adds the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Walls to add</param>
        /// <param name="Tiles">List of tiles generated by the borderawlls</param>
        /// <returns>Success</returns>
        private bool Add(BorderWalls w)
        {
            try
            {
                LevelParts.Add(w);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Adds the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <returns>Success</returns>
        internal bool Add(Wall w)
        {
            LevelParts.Add(w);
            return true;
        }

        /// <summary>
        /// Adds the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <returns>Success</returns>
        internal bool Add(Floor f)
        {
            LevelParts.Add(f);
            return true;
        }

        /// <summary>
        /// Determines what an object is and adds it to the level
        /// </summary>
        /// <param name="obj">Object we want to split and add</param>
        internal List<Tile> Add(LevelPart obj, bool dontAdd = false)
        {
            List<Tile> tiles = new List<Tile>();
            //deterime what it is
            if (obj is Room)
            {
                Room r = obj as Room;
                if (dontAdd || Add(r))
                {
                    //we're going to be getting them a lot otherwise
                    Index2D start = new Index2D(Math.Min(r.StartCell.X, r.EndCell.X), Math.Min(r.StartCell.Y, r.EndCell.Y));
                    Index2D end = new Index2D(Math.Max(r.StartCell.X, r.EndCell.X), Math.Max(r.StartCell.Y, r.EndCell.Y));
                    List<Tile> t;
                    Add(new BorderWalls(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Add(t[i]);
                    }

                    t = new List<Tile>();
                    Add(new Floor(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Add(t[i]);
                    }

                }
            }
            else if (obj is BorderWalls)
            {
                List<Tile> t = new List<Tile>();
                BorderWalls b = obj as BorderWalls;
                /// \todo Make this instead spit out a wall
                if (!(b.StartCell.X == b.EndCell.X || b.StartCell.Y == b.EndCell.Y))
                    Add(b, out t, dontAdd);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            else if (obj is Wall)
            {
                List<Tile> t;
                Add(obj as Wall, out t, dontAdd);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            else if (obj is Floor)
            {
                List<Tile> t;
                Add(obj as Floor, out t, dontAdd);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            return tiles;
        }

        #region Magic Adds

        /// <summary>
        /// Adds the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Walls to add</param>
        /// <param name="Tiles">Listof tiles generated by the borderawlls</param>
        /// <param name="dontAdd">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        private void Add(BorderWalls w, out List<Tile> Tiles, bool dontAdd = false)
        {
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));

            List<Tile> tiles = new List<Tile>();
            if (dontAdd || Add(w))
            {
                List<Tile> ts;
                //place Left wall
                Add(new Wall(new Index2D(start.X, start.Y + 1), new Index2D(start.X, end.Y - 1), Orientations.Left, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place right wall
                Add(new Wall(new Index2D(end.X, start.Y + 1), new Index2D(end.X, end.Y - 1), Orientations.Right, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place Top wall
                Add(new Wall(new Index2D(start.X + 1, start.Y), new Index2D(end.X - 1, start.Y), Orientations.Down, TileTypes.Wall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place Bottom wall
                Add(new Wall(new Index2D(start.X + 1, end.Y), new Index2D(end.X - 1, end.Y), Orientations.Down, TileTypes.Bottom, w.Theme), out ts, true);


                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place corners
                //TL
                Tile t = new Tile()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Left,
                    GridCell = start,
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);

                //TR
                t = new Tile()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Right,
                    GridCell = new Index2D(end.X, start.Y)
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);

                //BL
                t = new Tile()
                {
                    Type = TileTypes.BottomCorner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Left,
                    GridCell = new Index2D(start.X, end.Y)
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);

                //BR
                t = new Tile()
                {
                    Type = TileTypes.BottomCorner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Right,
                    GridCell = new Index2D(end.X, end.Y)
                };
                tiles.Add(t);
                Add(t, t.GridCell.X, t.GridCell.Y);
            }
            Tiles = tiles;
        }

        /// <summary>
        /// Adds the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <param name="dontAdd">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Add(Wall w, out List<Tile> Tiles, bool dontAdd = false)
        {
            List<Tile> tiles = new List<Tile>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));
            Index2D diff = end - start;
            if (dontAdd || Add(w))
            {
                //add tiles to the list
                if (w.Type == TileTypes.SideWall || diff.MagX < diff.MagY)
                {
                    //place on side

                    //Rt wall
                    if (w.Orientation == Orientations.Right || diff.X < 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Add Right
                            Tile t = new Tile()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Right,
                                GridCell = new Index2D(end.X, y)
                            };
                            tiles.Add(t);
                            Add(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                    //left wall
                    else if (w.Orientation == Orientations.Left || diff.X > 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Add left
                            Tile t = new Tile()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Left,
                                GridCell = new Index2D(start.X, y)
                            };
                            tiles.Add(t);
                            Add(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                }
                else if (w.Type == TileTypes.Wall || (diff.MagX > diff.MagY && w.Type == TileTypes.Wall))
                {
                    //Place top
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Add Top
                        Tile t = new Tile()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y >= 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, start.Y)
                        };
                        tiles.Add(t);
                        Add(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
                else if (w.Type == TileTypes.Bottom || (diff.MagX > diff.MagY && w.Type == TileTypes.Bottom))
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Add Bottom
                        Tile t = new Tile()
                        {
                            Type = TileTypes.Bottom,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = Orientations.Down,
                            GridCell = new Index2D(x, end.Y)
                        };
                        tiles.Add(t);
                        Add(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }

        /// <summary>
        /// Adds the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <param name="dontAdd">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Add(Floor f, out List<Tile> Tiles, bool dontAdd = false)
        {
            List<Tile> tiles = new List<Tile>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(f.StartCell.X, f.EndCell.X), Math.Min(f.StartCell.Y, f.EndCell.Y));
            Index2D end = new Index2D(Math.Max(f.StartCell.X, f.EndCell.X), Math.Max(f.StartCell.Y, f.EndCell.Y));
            if (dontAdd || Add(f))
            {
                //add tiles to the list
                //place floor
                for (int y = start.Y; y <= end.Y; y++)
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Add Bottom
                        Tile tile = new Tile()
                        {
                            Type = f.Type,
                            FloorType = f.FloorType,
                            Theme = f.Theme,
                            Traversable = f.Traversable,
                            Orientation = Orientations.Down,
                            GridCell = new Index2D(x, y)
                        };
                        tiles.Add(tile);
                        Add(tile, tile.GridCell.X, tile.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }
        #endregion Magic Adds
        #endregion Adds

        #region Removals
        public bool Remove(Tile t)
        {
            if (mTiles.Count > t.GridCell.Y && mTiles[t.GridCell.Y].Count > t.GridCell.X)
            {
                LevelParts.Remove(t);
                return Remove(t, t.GridCell.X, t.GridCell.Y);
            }
            else
                return false;
        }

        public bool Remove(Tile elem, int x, int y)
        {
            //if (!dontAddToUndo)
            //{
            //    var tiles = LevelParts.FindAll(delegate(LevelObject lo) { return lo is Tile) ? lo.GridCell == elem.GridCell : false; });
            //    if (tiles.Count > 0)
            //        RemovedTiles.Push(tiles);
            //}
            //else
            //{
            //    var tiles = LevelParts.FindAll(delegate(LevelObject lo) { return lo is Tile) ? lo.GridCell == elem.GridCell : false; });
            //    if (tiles.Count > 0)
            //        RedoTiles.Push(tiles);
            //}
            LevelParts.RemoveAll(delegate(LevelObject lo) { return lo is Tile ? lo.GridCell == elem.GridCell : false; });
            mTiles[y][x] = new Tile();
            return true;
        }

        /// <summary>
        /// Removes the Room to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Room to add</param>
        /// <returns>Success</returns>
        internal bool Remove(Room r)
        {
            LevelParts.Remove(r);
            //add tiles to the list
            return true;
        }

        /// <summary>
        /// Removes the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="r">Walls to add</param>
        /// <param name="Tiles">List of tiles generated by the borderawlls</param>
        /// <returns>Success</returns>
        private bool Remove(BorderWalls w)
        {
            try
            {
                LevelParts.Remove(w);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Removes the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <returns>Success</returns>
        internal bool Remove(Wall w)
        {
            LevelParts.Remove(w);
            return true;
        }

        /// <summary>
        /// Removes the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <returns>Success</returns>
        internal bool Remove(Floor f)
        {
            LevelParts.Remove(f);
            return true;
        }

        /// <summary>
        /// Determines what an object is and adds it to the level
        /// </summary>
        /// <param name="obj">Object we want to split and add</param>
        internal List<Tile> Remove(LevelPart obj, bool dontRemove = false)
        {
            List<Tile> tiles = new List<Tile>();
            //deterime what it is
            if (obj is Room)
            {
                Room r = obj as Room;
                if (Remove(r))
                {
                    //we're going to be getting them a lot otherwise
                    Index2D start = new Index2D(Math.Min(r.StartCell.X, r.EndCell.X), Math.Min(r.StartCell.Y, r.EndCell.Y));
                    Index2D end = new Index2D(Math.Max(r.StartCell.X, r.EndCell.X), Math.Max(r.StartCell.Y, r.EndCell.Y));
                    List<Tile> t;
                    Remove(new BorderWalls(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Add(t[i]);
                    }

                    t = new List<Tile>();
                    Remove(new Floor(r), out t, true);

                    //for some reson foreach doesn't work here
                    for (int i = 0; i < t.Count; i++)
                    {
                        tiles.Add(t[i]);
                    }
                }
            }
            else if (obj is BorderWalls)
            {
                List<Tile> t;
                Remove(obj as BorderWalls, out t, dontRemove);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            else if (obj is Wall)
            {
                List<Tile> t;
                Remove(obj as Wall, out t, dontRemove);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            else if (obj is Floor)
            {
                List<Tile> t;
                Remove(obj as Floor, out t, dontRemove);

                //for some reson foreach doesn't work here
                for (int i = 0; i < t.Count; i++)
                {
                    tiles.Add(t[i]);
                }
            }
            return tiles;
        }

        #region Magic Removes

        /// <summary>
        /// Removes the Walls to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Walls to add</param>
        /// <param name="Tiles">Listof tiles generated by the borderawlls</param>
        /// <param name="dontRemove">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        private void Remove(BorderWalls w, out List<Tile> Tiles, bool dontRemove = false)
        {
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));

            List<Tile> tiles = new List<Tile>();
            if (dontRemove || Remove(w))
            {
                List<Tile> ts;
                //place Left wall
                Remove(new Wall(new Index2D(start.X, start.Y + 1), new Index2D(start.X, end.Y - 1), Orientations.Left, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place right wall
                Remove(new Wall(new Index2D(end.X, start.Y + 1), new Index2D(end.X, end.Y - 1), Orientations.Right, TileTypes.SideWall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place Top wall
                Remove(new Wall(new Index2D(start.X + 1, start.Y), new Index2D(end.X - 1, start.Y), Orientations.Down, TileTypes.Wall, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place Top wall
                Remove(new Wall(new Index2D(start.X + 1, end.Y), new Index2D(end.X - 1, end.Y), Orientations.Down, TileTypes.Bottom, w.Theme), out ts, true);

                //for some reson foreach doesn't work here
                for (int i = 0; i < ts.Count; i++)
                {
                    tiles.Add(ts[i]);
                }

                //place corners
                //TL
                Tile t = new Tile()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Left,
                    GridCell = start,
                };
                tiles.Add(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);

                //TR
                t = new Tile()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Down,
                    GridCell = new Index2D(end.X, start.Y)
                };
                tiles.Add(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);

                //BL
                t = new Tile()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Up_Left,
                    GridCell = new Index2D(start.X, end.Y)
                };
                tiles.Add(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);

                //BR
                t = new Tile()
                {
                    Type = TileTypes.Corner,
                    Theme = w.Theme,
                    Traversable = false,
                    Orientation = Orientations.Up,
                    GridCell = new Index2D(end.X, end.Y)
                };
                tiles.Add(t);
                Remove(t, t.GridCell.X, t.GridCell.Y);
            }
            Tiles = tiles;
        }

        /// <summary>
        /// Removes the Wall to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="w">Wall to add</param>
        /// <param name="dontRemove">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Remove(Wall w, out List<Tile> Tiles, bool dontRemove = false)
        {
            List<Tile> tiles = new List<Tile>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(w.StartCell.X, w.EndCell.X), Math.Min(w.StartCell.Y, w.EndCell.Y));
            Index2D end = new Index2D(Math.Max(w.StartCell.X, w.EndCell.X), Math.Max(w.StartCell.Y, w.EndCell.Y));
            Index2D diff = end - start;
            if (dontRemove || Remove(w))
            {
                //add tiles to the list
                if (w.Type == TileTypes.SideWall || diff.MagX < diff.MagY)
                {
                    //place on side

                    //Rt wall
                    if (w.Orientation == Orientations.Right || diff.X < 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Remove Right
                            Tile t = new Tile()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Right,
                                GridCell = new Index2D(end.X, y)
                            };
                            tiles.Add(t);
                            Remove(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                    //left wall
                    else if (w.Orientation == Orientations.Left || diff.X > 0)
                    {
                        for (int y = start.Y; y <= end.Y; y++)
                        {
                            //Remove left
                            Tile t = new Tile()
                            {
                                Type = TileTypes.SideWall,
                                Theme = w.Theme,
                                Traversable = false,
                                Orientation = Orientations.Left,
                                GridCell = new Index2D(start.X, y)
                            };
                            tiles.Add(t);
                            Remove(t, t.GridCell.X, t.GridCell.Y);
                        }
                    }
                }
                else if (w.Type == TileTypes.Wall || (diff.MagX > diff.MagY && w.Type == TileTypes.Wall))
                {
                    //Place top
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Remove Top
                        Tile t = new Tile()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y >= 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, start.Y)
                        };
                        tiles.Add(t);
                        Remove(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
                else if (w.Type == TileTypes.Bottom || (diff.MagX > diff.MagY && w.Type == TileTypes.Bottom))
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Remove Bottom
                        Tile t = new Tile()
                        {
                            Type = TileTypes.Wall,
                            Theme = w.Theme,
                            Traversable = false,
                            Orientation = diff.Y < 0 ? Orientations.Down : Orientations.Up,
                            GridCell = new Index2D(x, end.Y)
                        };
                        tiles.Add(t);
                        Remove(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }

        /// <summary>
        /// Removes the Floor to ListObjects and adds all relevant cells to the grid
        /// </summary>
        /// <param name="f">Floor to add</param>
        /// <param name="dontRemove">True means the item added will not be added to the list of Levelobjects</param>
        /// <returns>Success</returns>
        internal bool Remove(Floor f, out List<Tile> Tiles, bool dontRemove = false)
        {
            List<Tile> tiles = new List<Tile>();
            //we're going to be getting them a lot otherwise
            Index2D start = new Index2D(Math.Min(f.StartCell.X, f.EndCell.X), Math.Min(f.StartCell.Y, f.EndCell.Y));
            Index2D end = new Index2D(Math.Max(f.StartCell.X, f.EndCell.X), Math.Max(f.StartCell.Y, f.EndCell.Y));
            if (dontRemove || Remove(f))
            {
                //add tiles to the list
                //place floor
                for (int y = start.Y; y <= end.Y; y++)
                {
                    for (int x = start.X; x <= end.X; x++)
                    {
                        //Remove Bottom
                        Tile t = new Tile()
                        {
                            Type = f.Type,
                            FloorType = f.FloorType,
                            Theme = f.Theme,
                            Traversable = f.Traversable,
                            Orientation = Orientations.Down,
                            GridCell = new Index2D(x, y)
                        };
                        tiles.Add(t);
                        Remove(t, t.GridCell.X, t.GridCell.Y);
                    }
                }
            }
            Tiles = tiles;
            return true;
        }
        #endregion Magic Removes
        #endregion Removals

        #region Access Values
        internal bool TryGetValue(int x, int y, out Tile value)
        {
            if (y >= 0 && y < mTiles.Count && x >= 0 && x < mTiles[0].Count)
            {
                if (cache_key.X == x && cache_key.Y == y)
                {
                    value = cache_value;
                    return true;
                }

                if (mTiles[y][x] != null)
                {
                    value = mTiles[y][x];
                    cache_key = new Index2D(x, y);
                    cache_value = value;
                    return true;
                }
            }
            value = new Tile() { GridCell = new Index2D(x, y) };
            return false;
        }

        internal void Clear()
        {
            mTiles.Clear();
        }

        /// <summary>
        /// Indexer into the list[]
        /// </summary>
        /// <param name="i">element</param>
        /// <returns>the list at that index</returns>
        public List<Tile> this[int i]
        {
            get
            {
                return mTiles[i];
            }
            set
            {
                mTiles[i] = value;
            }
        }

        public TileList Duplicate()
        {
            TileList n = new TileList();
            n.LevelParts = new List<LevelObject>(this.LevelParts);
            n.mTiles = new List<List<Tile>>();
            int ycount = mTiles.Count;
            if (ycount > 0)
            {
                int xcount = mTiles[0].Count;
                for (int y = 0; y < ycount; y++)
                {
                    n.mTiles.Add(new List<Tile>());
                    for (int x = 0; x < xcount; x++)
                    {
                        n.mTiles[y].Add(mTiles[y][x]);
                    }
                }
            }

            return n;
        }

        /// <summary>
        /// Obtains a list of tiles within the 2D range from top left to bottom right
        /// </summary>
        /// <param name="startCell">Top Left of the range</param>
        /// <param name="endCell">Bottom Right of the range</param>
        /// <returns>Lsit of all Tiles within the range</returns>
        internal List<Tile> GetCurrentState(Index2D startCell, Index2D endCell)
        {
            List<Tile> tiles = new List<Tile>();

            for (int row = startCell.Y, rowEnd = endCell.Y, col = Math.Min(startCell.X, endCell.X), colEnd = Math.Max(startCell.X, endCell.X); row <= rowEnd; row++)
            {
                //we want to make sure that we put in empty items
                //on our grid if our list is empty or the first element has GridCell == null (we can assume the whole set will)
                if (mTiles.Count > 0 &&
                    mTiles.Count > row &&//make sure the row exists
                    mTiles[row].Count > col &&//make sure the col exists
                    mTiles[row].Count > colEnd //make sure the colEnd exists
                   )
                    for (col = Math.Min(startCell.X, endCell.X); col <= colEnd; col++)
                    {
                        Tile t = mTiles[row][col];
                        tiles.Add(t.GridCell != null ? t : new Tile() { GridCell = new Index2D(col, row) });
                    }
                else
                    for (col = Math.Min(startCell.X, endCell.X); col <= colEnd; col++)
                    {
                        tiles.Add(new Tile() { GridCell = new Index2D(col, row) });
                    }
            }
            return tiles;
        }

        /// <summary>
        /// Sets the portion of the grid corresponding to these tiles to these tiles. 
        /// Wipes current data. 
        /// Only functions if the tiles already have data
        /// </summary>
        /// <param name="list">List of tiles to place where they go</param>
        internal void SetState(List<Tile> list, List<Tile> ts = null)
        {
            if (mTiles.Count > 0)
            {
                //if the tiles existed we set them back
                if (list.Count > 0 && list[0].GridCell != null)
                    foreach (var tile in list)
                    {
                        if (tile.GridCell != null)
                            mTiles[tile.GridCell.Y][tile.GridCell.X] = tile;
                    }
                //else if(ts!=null)
                //{
                //    foreach (var tile in ts)
                //    {
                //        mTiles[tile.GridCell.Y][tile.GridCell.X] = new Tile();
                //    }
                //}
            }
        }

        /// <summary>
        /// Returns the MaxColumn that the list has. Returns -1 if the list is empty
        /// </summary>
        public int MaxColumn
        {
            get
            {
                return mTiles.Count > 0 ? mTiles[0].Count - 1 : -1;
            }
        }
        /// <summary>
        /// Returns the MaxRow that the list has. Returns -1 if the list is empty
        /// </summary>
        public int MaxRow
        {
            get
            {
                return mTiles.Count - 1;
            }
        }
        #endregion Access Values

        #region Saving
        /// <summary>
        /// creates all the rooms, tiles, etc that would be needed to generate the level
        /// </summary>
        /// <returns></returns>
        public List<LevelObject> GenerateSaveObjects(Element theme = Element.DEFAULT)
        {
            List<LevelObject> objs = new List<LevelObject>();
            TileList copy = Duplicate();
            //remove from copy all the tiles that match our current objects
            foreach (var lo in LevelParts)
            {
                if (lo is LevelPart)
                {
                    List<Tile> removed = copy.Add(lo as LevelPart);
                    objs.Add(lo);
                    //foreach (Tile tile in removed)
                    //{
                    //    Index2D cell = tile.GridCell;
                    //    if (mTiles[cell.Y][cell.X] == tile)
                    //    {
                    //        copy.Add(tile);
                    //    }
                    //}
                }
                else if (lo is Tile)
                {
                    Tile tile = lo as Tile;
                    if (tile.Theme == Element.DEFAULT)
                        tile.Theme = theme;
                    objs.Add(lo);
                    Index2D cell = tile.GridCell;
                    if (mTiles[cell.Y][cell.X] == tile)
                    {
                        copy.Add(tile);
                    }
                }
            }
            int ycount = mTiles.Count;
            if (ycount > 0)
            {
                int xcount = mTiles[0].Count;
                for (int y = 0; y < ycount; y++)
                {
                    for (int x = 0; x < xcount; x++)
                    {
                        Tile tileFromCopy = copy[y][x];
                        Tile tileFromUs = this[y][x];
                        //this means it's a tile we care about
                        if (tileFromCopy != tileFromUs)
                        {
                            if (tileFromUs.Theme == Element.DEFAULT)
                                tileFromUs.Theme = theme;
                            if (tileFromUs.GridCell == null)
                                tileFromUs.GridCell = new Index2D(x, y);
                            objs.Add(tileFromUs);
                        }
                    }
                }
            }

            return objs;
        }

        /// <summary>
        /// Saves the Document to the given tile
        /// </summary>
        /// <param name="filename">SaveFile name</param>
        /// <param name="doc">Document to save</param>
        public void Save(string filename, XDocument doc)
        {
            doc.Save(filename);
        }

        /// <summary>
        /// Generates the XDocument with all our data.
        /// </summary>
        /// <returns>XDocument form of the level</returns>
        public XDocument Serialize()
        {
            XDocument doc = new XDocument(new XElement("Level"));

            return doc;
        }
        #endregion Saving

        #region Loading
        /// <summary>
        /// Loads File
        /// </summary>
        /// <param name="filename">Name of the file to load</param>
        /// <returns>The object created</returns>
        public static TileList Load(string filename)
        {
            return Parse(XDocument.Load(filename));
        }

        /// <summary>
        /// parses an xdocument and re
        /// </summary>
        /// <param name="doc"></param>
        /// <returns></returns>
        public static TileList Parse(XDocument doc)
        {
            return new TileList(doc);
        }
        #endregion Loading

        #region Properties
        public bool HasItems
        {
            get
            {
                return mTiles.Count > 0;
            }
        }
        #endregion Properties
    }
}
